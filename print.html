<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using rust to implement the simulated annealing algorithm</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Using rust to implement the simulated annealing algorithm</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="using-rust-to-implement-the-simulated-annealing-algorithm"><a class="header" href="#using-rust-to-implement-the-simulated-annealing-algorithm">Using Rust to Implement the Simulated Annealing Algorithm</a></h1>
<p>This tutorial is for experienced bioinformaticians who have been programming in R and/or Python, or other scripting languages. If you have experience with C, C++, or Julia, that will also be beneficial.</p>
<p>While R is widely used in bioinformatics for statistical analysis and data manipulation, Rust is a <strong>systems programming language</strong> that provides <strong>strong type safety, memory safety without garbage collection</strong>, and <strong>high performance</strong>. This tutorial will introduce key differences between R and Rust and guide you through implementing a simulated annealing algorithm in Rust.</p>
<hr />
<h2 id="rust-vs-r-key-differences"><a class="header" href="#rust-vs-r-key-differences">Rust vs. R: Key Differences</a></h2>
<p>Before diving into the implementation, let's highlight a few <strong>fundamental differences between R and Rust</strong> that will be important for this tutorial:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>R (Scripting Language)</th><th>Rust (Systems Language)</th></tr></thead><tbody>
<tr><td><strong>Typing</strong></td><td>Dynamic (e.g., <code>x &lt;- 10</code> can later be <code>x &lt;- "text"</code>)</td><td>Static (types must be defined, e.g., <code>let x: i32 = 10;</code>)</td></tr>
<tr><td><strong>Memory Management</strong></td><td>Garbage collection</td><td>Ownership and borrowing</td></tr>
<tr><td><strong>Performance</strong></td><td>Optimized for high-level analysis</td><td>Compiled, low-level efficiency</td></tr>
<tr><td><strong>Object-Oriented Features</strong></td><td>R has S3, S4, and R6 classes but isn't purely OO</td><td>Rust supports structs and traits for OO-like behavior</td></tr>
<tr><td><strong>Concurrency</strong></td><td>Limited parallel processing</td><td>Strong concurrency model with <code>async</code> and threads</td></tr>
</tbody></table>
</div>
<p>Understanding these differences will help when translating concepts from R to Rust.</p>
<hr />
<h2 id="a-quick-refresher-object-oriented-programming-oo"><a class="header" href="#a-quick-refresher-object-oriented-programming-oo"><strong>A Quick Refresher: Object-Oriented Programming (OO)</strong></a></h2>
<p>Although <strong>R is not strictly an object-oriented language</strong>, it does support OO through <strong>S3, S4, and R6 classes</strong>. Rust, on the other hand, does not have traditional classes like Python or Java but instead <strong>uses structs and traits</strong> to achieve similar functionality.</p>
<p>Here’s a quick comparison of how <strong>objects and methods</strong> are implemented in R and Rust:</p>
<h3 id="r-example-object-oriented-approach-using-s3"><a class="header" href="#r-example-object-oriented-approach-using-s3"><strong>R Example: Object-Oriented Approach Using S3</strong></a></h3>
<pre><code class="language-r"># Define an S3 object
cluster &lt;- list(centroid = c(2.3, 3.4), members = c(1, 5, 9))
class(cluster) &lt;- "Cluster"

# Define a method for the Cluster class
print.Cluster &lt;- function(obj) {
  cat("Cluster centroid at:", obj$centroid, "
")
}

# Use the method
print(cluster)
</code></pre>
<h3 id="rust-equivalent-using-structs-and-traits"><a class="header" href="#rust-equivalent-using-structs-and-traits"><strong>Rust Equivalent: Using Structs and Traits</strong></a></h3>
<pre><pre class="playground"><code class="language-rust">struct Cluster {
    centroid: (f64, f64),
    members: Vec&lt;u32&gt;,
}

impl Cluster {
    fn print(&amp;self) {
        println!("Cluster centroid at: {:?}", self.centroid);
    }
}

fn main() {
    let cluster = Cluster {
        centroid: (2.3, 3.4),
        members: vec![1, 5, 9],
    };

    cluster.print();
}</code></pre></pre>
<h3 id="key-takeaways"><a class="header" href="#key-takeaways"><strong>Key Takeaways</strong></a></h3>
<ul>
<li><strong>R uses lists and S3/S4 classes for OO design</strong>, whereas <strong>Rust uses structs and traits</strong>.</li>
<li><strong>Methods in R</strong> are just functions that check an object's class, while <strong>Rust uses <code>impl</code> blocks</strong> to define methods.</li>
<li><strong>Rust enforces type safety at compile time</strong>, while <strong>R allows more flexibility</strong> at the cost of runtime type checking.</li>
</ul>
<hr />
<h2 id="the-problem-clustering-expression-data-using-simulated-annealing"><a class="header" href="#the-problem-clustering-expression-data-using-simulated-annealing"><strong>The Problem: Clustering Expression Data Using Simulated Annealing</strong></a></h2>
<p>The algorithm we will implement is based on the final project from our <a href="https://sccbioinformatics.github.io/R_programming_1/#The_Final_Project"><strong>first R programming course.</strong></a>
It clusters gene expression data using <strong>simulated annealing</strong>, a probabilistic optimization method. This algorithm is <strong>simple to understand and implement</strong>, but it also touches on several <strong>important programming concepts</strong>, including:</p>
<ul>
<li><strong>File reading</strong></li>
<li><strong>Control flow (loops, conditionals)</strong></li>
<li><strong>Data structures (vectors, matrices, hashes)</strong></li>
<li><strong>Mathematical operations</strong></li>
<li><strong>Performance considerations</strong></li>
</ul>
<h3 id="the-data"><a class="header" href="#the-data"><strong>The Data</strong></a></h3>
<p>For this problem, we will use <strong>yeast cell-cycle data</strong>, which is a small <strong>time-course dataset</strong> consisting of <strong>250 genes across 16 timepoints</strong>. The data is available here:<br />
🔗 <a href="https://github.com/shambam/R_programming_1/blob/main/Spellman_Yeast_Cell_Cycle.tsv">Spellman_Yeast_Cell_Cycle.tsv</a></p>
<h4 id="biological-context"><a class="header" href="#biological-context"><strong>Biological Context</strong></a></h4>
<p>Yeast in liquid culture were synchronized at the <strong>same cell-cycle phase</strong> and then released. They underwent <strong>two synchronized divisions</strong>, and samples were taken at <strong>16 timepoints</strong>. Since genes involved in the same biological processes tend to have similar expression patterns, this dataset contains <strong>distinct clusters of co-regulated genes</strong>. Our task is to <strong>cluster genes based on their expression profiles</strong> using simulated annealing.</p>
<h2 id="simulated-annealing"><a class="header" href="#simulated-annealing">Simulated annealing</a></h2>
<!--
Now, suppose we have 1,000 genes and we want to partition them into 10 clusters. The number of possible clusterings is astronomically large, making it infeasible to try every combination to find the true minimum <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>. 
This is why we turn to heuristic algorithms — methods that guide us toward a near-optimal solution in a reasonable amount of time.
-->
<p>We can think of well-clustered data as having low energy, meaning each cluster is tight and exhibits low within-cluster variance. If we calculate the variance within each cluster and sum over all clusters, we obtain the total variance, which we interpret as the energy of the system.</p>
<p>To measure the distance between two genes ii and jj across tt time points, we use the Euclidean distance:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.5561em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2839em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8065em;"><span style="top:-2.4542em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4542em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.2439em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.88em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90 l0 -0 c4,-6.7,10,-10,18,-10 H400000v40 H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7 s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744 c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30 c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722 c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5 c53.7,-170.3,84.5,-266.8,92.5,-289.5z M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5561em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>To quantify the energy (i.e., total variance) of a clustering, we compute the sum of all pairwise distances within each cluster <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, then average this across all <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> clusters:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v0 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">ϵ</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight">ϵ</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v0 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>For well-clustered data, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> should be as small as possible.</p>
<p>For a well clustered data, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> should be as <strong>small</strong> as possible. Lets say we have 1000 genes, and we want to partition them into 10 clusters. The number of combinations is too high for us to try each one to brute force a true <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>. This is why we use a <em>heuristic</em> algorithm to get us as close to the solution as possible in a smaller amount of time.</p>
<p>If we tried to visualise the energy landscape we can imagine it might look something like this:</p>
<p align="center">
  <img src="images/EnergyLandscape.png" alt="Energy Landscape" width="60%">
</p>
<p>The idea behind simulated annealing is that "bad" moves are also allowed for a proportion of the iterations allowing exploration of the energy landscape, thereby avoiding local minima.</p>
<h2 id="the-algorithm"><a class="header" href="#the-algorithm">The Algorithm</a></h2>
<p>I do not want to focus too much onto the algoirithm here as the main focus is on the Rust implementation, but the steps that need to be run are as follows:</p>
<ol>
<li>Load the data and scale it so each gene's value lie between 0 and 1</li>
<li>Create a random cluster information and calculate the energy of this clustering</li>
<li>Randomly shift any gene from it's cluster to another</li>
<li>Calculate the new energy and check if the new cluster info should be kept; do that</li>
<li>Repeat 3 and 4 for n iterations</li>
<li>report the cluster information - if possible create plots</li>
</ol>
<p>And all of that in Rust ;-)</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variables---strict-types-and-ownership-in-rust"><a class="header" href="#variables---strict-types-and-ownership-in-rust">Variables - Strict Types and Ownership in Rust</a></h1>
<h2 id="strict-types-in-rust"><a class="header" href="#strict-types-in-rust">Strict Types in Rust</a></h2>
<p>Rust is a statically typed language, meaning you <strong>must define the types</strong> of variables and data structures explicitly. This ensures <strong>type safety</strong> at <strong>compile time</strong>.</p>
<h3 id="example-1-strict-typing-in-rust"><a class="header" href="#example-1-strict-typing-in-rust">Example 1: Strict Typing in Rust</a></h3>
<p>Let's start by defining variables with specific types:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let integer: i32 = 10;  // 32-bit signed integer
    let floating_point: f64 = 10.5;  // 64-bit floating-point number
    let boolean: bool = true;  // Boolean value

    println!("Integer: {}, Floating-point: {}, Boolean: {}", integer, floating_point, boolean);
}</code></pre></pre>
<p>This does work as expected, but what happens if we set the boolean to 1 instead?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let integer: i32 = 10;  // 32-bit signed integer
    let floating_point: f64 = 10.5;  // 64-bit floating-point number
    let boolean: bool = 1;  // Boolean value

    println!("Integer: {}, Floating-point: {}, Boolean: {}", integer, floating_point, boolean);
}</code></pre></pre>
<h4 id="what-happens-here"><a class="header" href="#what-happens-here">What happens here?</a></h4>
<ul>
<li>Rust expects each variable to be of the specified type (<code>i32</code>, <code>f64</code>, <code>bool</code>).</li>
<li>If you try to assign a value with an incompatible type (e.g., <code>1</code> to an <code>bool</code>), the <strong>compiler will throw an error</strong>.</li>
</ul>
<pre><code>error[E0308]: mismatched types
 --&gt; src\main.rs:8:9
  |
4 |     let boolean: bool = 1;
  |         ^^^^^^^^^^^^^^ expected 'bool', found floating-point number
</code></pre>
<p>This strict checking ensures type safety and helps avoid runtime errors related to type mismatches.</p>
<h4 id="key-points"><a class="header" href="#key-points">Key Points:</a></h4>
<ul>
<li><strong>Rust enforces type correctness at compile time</strong>. You <strong>cannot implicitly convert between types</strong> (like R or Python might allow).</li>
<li><strong>Explicit type annotations</strong> help prevent unintended errors and increase code clarity.</li>
</ul>
<hr />
<h2 id="ownership-in-rust"><a class="header" href="#ownership-in-rust">Ownership in Rust</a></h2>
<p>One of Rust's most important and unique features is its <strong>ownership model</strong>. It ensures <strong>memory safety</strong> by enforcing strict rules about <strong>who owns data</strong> and when data is <strong>dropped (freed)</strong>.</p>
<h3 id="ownership-rules-in-rust"><a class="header" href="#ownership-rules-in-rust">Ownership Rules in Rust:</a></h3>
<ol>
<li><strong>Each value in Rust has a single owner</strong>.</li>
<li><strong>When the owner goes out of scope</strong>, Rust <strong>automatically frees the memory</strong>.</li>
<li><strong>You cannot have more than one owner</strong> at a time. If you want to <strong>transfer ownership</strong>, you use <strong>borrowing</strong> or <strong>cloning</strong>.</li>
</ol>
<h3 id="example-2-ownership-in-rust"><a class="header" href="#example-2-ownership-in-rust">Example 2: Ownership in Rust</a></h3>
<p>Let's look at a simple example that demonstrates ownership.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello, Rust!");  // s1 owns the String

    let s2 = s1;  // Ownership of the String is moved from s1 to s2
    println!("{}", s2);  // This works, since s2 is the owner now

    // After s2 goes out of scope, the memory will be freed.
}</code></pre></pre>
<p>This version simply prints the values from s2 - but would s1 still be usable?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello, Rust!");  // s1 owns the String

    let s2 = s1;  // Ownership of the String is moved from s1 to s2
    println!("{}", s1);  // This works, since s2 is the owner now

    // After s2 goes out of scope, the memory will be freed.
}</code></pre></pre>
<p>let s2 = s1.clone();  // Ownership of the String is moved from s1 to s2
|</p>
<h4 id="explanation"><a class="header" href="#explanation">Explanation:</a></h4>
<ul>
<li><code>s1</code> is the <strong>owner</strong> of the <code>String</code> object.</li>
<li>When <code>s1</code> is assigned to <code>s2</code>, <strong>ownership</strong> of the <code>String</code> is <strong>moved</strong> from <code>s1</code> to <code>s2</code>.</li>
<li>After the move, <code>s1</code> is no longer valid, and trying to use it (e.g., <code>println!("{}", s1)</code>) will result in a <strong>compiler error</strong>:
<pre><code>error[E0382]: use of moved value: `s1`
 --&gt; src\main.rs:7:22
  |
7 |     println!("{}", s1);  // ERROR: value moved, cannot use
  |                      ^^^ value moved here
</code></pre>
</li>
</ul>
<p>This behavior is critical because it ensures that <strong>Rust doesn’t accidentally create multiple owners</strong> of the same data (which could lead to <strong>data races or memory leaks</strong>).</p>
<p>And you also see that the Rust compiler directly tries to give you a hint in how to circumvent this problem:</p>
<pre><code>help: consider cloning the value if the performance cost is acceptable
  |
4 |   let s2 = s1.clone();  // Ownership of the String is moved from s1 to s2
  |     
</code></pre>
<h3 id="example-3-borrowing-in-rust"><a class="header" href="#example-3-borrowing-in-rust">Example 3: Borrowing in Rust</a></h3>
<p>Rust allows you to <strong>borrow</strong> data, either immutably or mutably.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello, Rust!");  // s1 owns the String

    // Immutable Borrowing
    let s2 = &amp;s1;  // s2 borrows s1 immutably
    println!("{}", s2);  // This works because s2 is just borrowing s1

    // Mutable Borrowing
    let mut s3 = String::from("Mutable borrow!");
    let s4 = &amp;mut s3;  // s4 borrows s3 mutably
    s4.push_str(" Now it’s mutable!");
    println!("{}", s4);  // Prints: Mutable borrow! Now it’s mutable!
    
    // You can't have both mutable and immutable borrows at the same time:
    let s5 = &amp;s1;  // ERROR: cannot borrow `s1` as immutable because it's already borrowed as mutable
}</code></pre></pre>
<h4 id="explanation-1"><a class="header" href="#explanation-1">Explanation:</a></h4>
<ul>
<li><strong>Immutable borrowing</strong> (<code>let s2 = &amp;s1</code>) allows multiple references to the same data but <strong>doesn’t allow modification</strong>.</li>
<li><strong>Mutable borrowing</strong> (<code>let s4 = &amp;mut s3</code>) gives exclusive access to the data, and <strong>no other borrows</strong> (immutable or mutable) can exist while it’s borrowed mutably.</li>
<li>The rules prevent <strong>data races</strong> by ensuring no one can have mutable access while others are reading (or mutably accessing the data).</li>
</ul>
<hr />
<h2 id="combining-types-and-ownership"><a class="header" href="#combining-types-and-ownership">Combining Types and Ownership</a></h2>
<p>Let's combine both <strong>strict typing</strong> and <strong>ownership</strong> in a small example where we use both concepts together.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num: i32 = 42;  // i32 type (strict typing)
    let num_copy = num;  // Ownership of num is copied to num_copy (as num is Copy type)

    println!("num: {}, num_copy: {}", num, num_copy);  // Both can still be used

    let s1 = String::from("Rust Ownership!");  // String type (non-Copy type)
    let s2 = s1;  // Ownership of s1 is moved to s2
    // println!("{}", s1);  // ERROR: s1 is no longer valid
    println!("{}", s2);  // This works, since s2 now owns the String
}</code></pre></pre>
<h3 id="output"><a class="header" href="#output">Output:</a></h3>
<pre><code>num: 42, num_copy: 42
Rust Ownership!
</code></pre>
<ul>
<li><strong>Copy types</strong> (like <code>i32</code>) do not move ownership. They <strong>duplicate the data</strong> when assigned to another variable.</li>
<li><strong>Non-copy types</strong> (like <code>String</code>) <strong>move ownership</strong> when assigned to another variable, which makes the first variable invalid.</li>
</ul>
<hr />
<h2 id="summary-of-ownership-and-strict-types"><a class="header" href="#summary-of-ownership-and-strict-types">Summary of Ownership and Strict Types:</a></h2>
<ul>
<li><strong>Rust’s strict typing</strong> ensures type safety at compile time, preventing mismatched types and logic errors that would only be caught at runtime in languages like R or Python.</li>
<li><strong>Rust’s ownership model</strong> prevents issues like double freeing of memory and data races, making it one of the <strong>safest systems languages</strong> available. The rules around ownership, borrowing, and moving data are <strong>central to memory management</strong> in Rust, giving developers fine-grained control over memory safety without a garbage collector.</li>
</ul>
<p>Even so will not face these problems today it's extremely important to know about this before you try to program in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="create-a-rust-project-and-implement-the-class"><a class="header" href="#create-a-rust-project-and-implement-the-class">Create a Rust Project and Implement the Class</a></h1>
<p>A Rust <strong>class</strong> is a combination of a struct- (data) and an impl-block (functions). But as in R a Rust <strong>package</strong> contains several other important files and a specific folder structure.</p>
<p>As an R programmer, you're likely familiar with using tools like devtools to streamline the creation of R packages. In Rust, the process of setting up a new package is just as straightforward, though the terminology and structure differ slightly.</p>
<p>This will create the folder, populate it with some files and prepare it for git usage.</p>
<pre><code>cargo new --bin simulated_annealing
</code></pre>
<p>For later use we create a <strong>simulated_annealing/tests</strong> folder and a <strong>simulated_annealing/src/lib.rs</strong> file.</p>
<p>I normally put as much code into the library and keep the script as slender as possible.</p>
<h2 id="for-the-class---which-data-structures-do-we-need"><a class="header" href="#for-the-class---which-data-structures-do-we-need">For the class - which data structures do we need?</a></h2>
<ol>
<li>The 'expression' data</li>
<li>The rows &lt;-&gt; cluster connections</li>
<li>The number of clusters asked for</li>
<li>The actual temperature of the system</li>
</ol>
<p>** Let's create the object**</p>
<p>Open the src/lib.rs file and add this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct SimulatedAnnealing {
    /// the normalized expression data
    pub data: Vec&lt;Vec&lt;f32&gt;&gt;,
    /// the names for each row
    rownames: Vec&lt;String&gt;,
    /// the cluster ids for each row of data
    clusters: Vec&lt;usize&gt;,
    /// expected clusters k
    k: usize,
    /// the actual temerature
    temp:f32,
}

impl SimulatedAnnealing {
    pub fn new( file_path:&amp;str, k:usize, temp:f32, split:char ) -&gt; Self{

        let (rownames, data) = Self::read_table_with_names( file_path, split ).unwrap();

        let clusters: Vec&lt;usize&gt; = rownames.iter().map(|_| rand::thread_rng().gen_range(1..=k)).collect();

        Self{
            data,
            rownames,
            clusters,
            clusters_energy: vec![0.0; k ],
            temp,
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>This will define a class with the variables data, rownames, clusters, k and temp as well as the new() function for this class, which in turn populates these variables with initial values. Save the file and try to compile your project using</p>
<pre><code class="language-bash">cargo test -r
</code></pre>
<pre><code class="language-text">   Compiling simulated_annealing v0.1.0 (/home/med-sal/git_Projects/mdbook_simulted_annealing_in_rust/rust_stages/step1)
error[E0599]: no function or associated item named `read_table_with_names` found for struct `SimulatedAnnealing` in the current scope
  --&gt; src/lib.rs:21:38
   |
2  | pub struct SimulatedAnnealing {
   | ----------------------------- function or associated item `read_table_with_names` not found for this struct
...
21 |         let (rownames, data) = Self::read_table_with_names( file_path, split ).unwrap();
   |                                      ^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SimulatedAnnealing`
   |
note: if you're trying to build a new `SimulatedAnnealing`, consider using `SimulatedAnnealing::new` which returns `SimulatedAnnealing`
  --&gt; src/lib.rs:19:5
   |
19 |     pub fn new( file_path:&amp;str, k:usize, temp:f32, split:char ) -&gt; Self{
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0433]: failed to resolve: use of undeclared crate or module `rand`
  --&gt; src/lib.rs:23:60
   |
23 |         let clusters: Vec&lt;usize&gt; = rownames.iter().map(|_| rand::thread_rng().gen_range(0..k)).collect();
   |                                                            ^^^^ use of undeclared crate or module `rand`

Some errors have detailed explanations: E0433, E0599.
For more information about an error, try `rustc --explain E0433`.
error: could not compile `simulated_annealing` (lib) due to 2 previous errors
warning: build failed, waiting for other jobs to finish...
error: could not compile `simulated_annealing` (lib test) due to 2 previous errors

</code></pre>
<h3 id="missing-library-error"><a class="header" href="#missing-library-error">missing library error:</a></h3>
<p>Right - we try to create the random cluster info and have not loaded the required package. That is simple to do in Rust:</p>
<pre><code>cargo add rand
</code></pre>
<p>This will download and compile the rand crate and add the rand package as depencancy in Cargo.toml.
Do not forget to also load that library in the lib.rs file - at the top of that file add <code>use rand::Rng;</code>.</p>
<h3 id="missing-function-error"><a class="header" href="#missing-function-error">missing function error:</a></h3>
<p>The read_table function is more complicated.
I normally out-source these simple, but tedious steps to ChatGPT or an other AI helper, but these are the steps we need to take:</p>
<ol>
<li>create a Path from the <code>&amp;str</code> file_name</li>
<li>open that Path</li>
<li>create a BuffReader from that File to more efficiently read from it</li>
<li>iterate over the lines and</li>
<li>split the line by sep (could be user defined too - or?)</li>
<li>use the first entry as rowname (String) and the rest as numeric (f32).</li>
</ol>
<p>To fix the issues you need load these libraries at the beginning of the lib.rs file:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
use std::fs::File;
use std::io::{BufReader, BuffRead};
use rand::Rng;
<span class="boring">}</span></code></pre></pre>
<p>And then add the following rust function into the impl block:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn read_table_with_names(file_path: &amp;str, split: char ) -&gt; Result&lt;( Vec&lt;String&gt;, Vec&lt;Vec&lt;f32&gt;&gt;), String&gt; {
        let path = Path::new(file_path);
        let file = match File::open(path){
          Ok(f) =&gt; f,
          Err(e) =&gt; {
            return Err( format!("Failed to open file: {}", e) )
          }
        };
        let reader = BufReader::new(file);

        let mut data = Vec::new();
        let mut rownames= Vec::new();

        for (line_num, line) in reader.lines().enumerate() {
            let line = line.map_err(|e| format!("Error reading line {}: {}", line_num + 1, e))?;
            let mut parts = line.split( split );

            let row_name = parts.next().ok_or_else(|| format!("Missing row name at line {}", line_num + 1))?;
            if row_name == "" {
                // ignore column names
                continue;
            }
            rownames.push( row_name.to_string() );

            let values: Result&lt;Vec&lt;f32&gt;, String&gt; = parts
                .map(|num| num.parse::&lt;f32&gt;().map_err(|_| format!("Invalid number '{}' at line {}", num, line_num + 1)))
                .collect();

            let values = values.unwrap(); // will die on error
            data.push( values );
        }

        Ok( (rownames,data) )
    }
<span class="boring">}</span></code></pre></pre>
<p><strong>Understanding <code>read_table_with_names</code></strong></p>
<p>If you're an R developer, think of it as a combination of <code>read.table()</code> with custom handling for row names and numeric conversion.</p>
<h2 id="function-overview"><a class="header" href="#function-overview">Function Overview</a></h2>
<h3 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read_table_with_names(file_path: &amp;str, split: char ) -&gt; Result&lt;( Vec&lt;String&gt;, Vec&lt;Vec&lt;f32&gt;&gt;), String&gt;
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ul>
<li>Takes a <strong>file path</strong> (<code>file_path: &amp;str</code>) as a string reference.</li>
<li>Accepts a <strong>delimiter character</strong> (<code>split: char</code>) to separate values.</li>
<li>Returns a <strong>Result type</strong> containing either:
<ul>
<li>A tuple of <strong>row names</strong> (<code>Vec&lt;String&gt;</code>) and <strong>numeric data matrix</strong> (<code>Vec&lt;Vec&lt;f32&gt;&gt;</code>).</li>
<li>Or an error message (<code>String</code>) in case of failure.</li>
</ul>
</li>
</ul>
<h2 id="breaking-it-down"><a class="header" href="#breaking-it-down">Breaking It Down</a></h2>
<h3 id="step-1-open-the-file"><a class="header" href="#step-1-open-the-file">Step 1: Open the File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = Path::new(file_path);
let file = match File::open(path){
    Ok(f) =&gt; f,
    Err(e) =&gt; {
        return Err(format!("Failed to open file: {}", e));
    }
};
<span class="boring">}</span></code></pre></pre>
<p><strong>What it does:</strong></p>
<ul>
<li>Converts <code>file_path</code> into a <code>Path</code> object.</li>
<li>Tries to open the file using <code>File::open(path)</code>. If successful, it assigns the file handle to <code>f</code>.</li>
<li>If the file opening fails, it returns an error message.</li>
</ul>
<p><strong>R Equivalent:</strong></p>
<pre><code class="language-r">if (!file.exists(file_path)) {
  stop(paste("Failed to open file:", file_path))
}
</code></pre>
<h3 id="step-2-prepare-the-variables"><a class="header" href="#step-2-prepare-the-variables">Step 2: Prepare the Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader = BufReader::new(file);
let mut data = Vec::new();
let mut rownames = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><strong>What it does:</strong></p>
<ul>
<li>Wraps the file handle in <code>BufReader</code> for efficient line-by-line reading.</li>
<li>Initializes empty vectors:
<ul>
<li><code>data</code>: Stores numeric values (like a matrix in R).</li>
<li><code>rownames</code>: Stores row names.</li>
</ul>
</li>
</ul>
<h3 id="step-3-parse-each-line"><a class="header" href="#step-3-parse-each-line">Step 3: Parse Each Line</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (line_num, line) in reader.lines().enumerate() {
    let line = line.map_err(|e| format!("Error reading line {}: {}", line_num + 1, e))?;
    let mut parts = line.split(split);
<span class="boring">}</span></code></pre></pre>
<p><strong>What it does:</strong></p>
<ul>
<li>Iterates over each line, keeping track of line numbers.</li>
<li>Splits the line into separate values based on <code>split</code> (e.g., <code>\t</code> for TSV, <code>,</code> for CSV).</li>
<li>Handles file reading errors gracefully.</li>
</ul>
<h3 id="step-4-extract-row-names"><a class="header" href="#step-4-extract-row-names">Step 4: Extract Row Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let row_name = parts.next().ok_or_else(|| format!("Missing row name at line {}", line_num + 1))?;
if row_name == "" {
    continue; // Ignore column names
}
rownames.push(row_name.to_string());
<span class="boring">}</span></code></pre></pre>
<p><strong>What it does:</strong></p>
<ul>
<li>Retrieves the first value from the line as the <strong>row name</strong>.</li>
<li>If no row name is found, it returns an error.</li>
<li>Skips empty row names (useful for ignoring headers).</li>
<li>Adds valid row names to <code>rownames</code>.</li>
</ul>
<p><strong>R Equivalent:</strong></p>
<pre><code class="language-r">data &lt;- read.table(file_path, sep="\t", header=TRUE, row.names=1)
rownames &lt;- rownames(data)
</code></pre>
<h3 id="step-5-convert-remaining-values-to-f32"><a class="header" href="#step-5-convert-remaining-values-to-f32">Step 5: Convert Remaining Values to <code>f32</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values: Result&lt;Vec&lt;f32&gt;, String&gt; = parts
    .map(|num| num.parse::&lt;f32&gt;().map_err(|_| format!("Invalid number '{}' at line {}", num, line_num + 1)))
    .collect();
let values = values.unwrap();
data.push(values);
<span class="boring">}</span></code></pre></pre>
<p><strong>What it does:</strong></p>
<ul>
<li>Attempts to convert each remaining value in the row into <code>f32</code>.</li>
<li>If a value is invalid, an error message is returned.</li>
<li>Pushes the successfully parsed row into <code>data</code>.</li>
</ul>
<p><strong>R Equivalent:</strong></p>
<pre><code class="language-r">data_matrix &lt;- as.matrix(data)
data_matrix &lt;- apply(data_matrix, 2, as.numeric) # Convert to numeric
</code></pre>
<h3 id="step-6-return-the-parsed-data"><a class="header" href="#step-6-return-the-parsed-data">Step 6: Return the Parsed Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Ok((rownames, data))
<span class="boring">}</span></code></pre></pre>
<ul>
<li>If everything succeeds, returns a tuple: <strong>(row names, numeric matrix)</strong>.</li>
<li>The <code>Result</code> type ensures proper error handling.</li>
</ul>
<h3 id="why-are-there-so-many-ways-to-create-the-error"><a class="header" href="#why-are-there-so-many-ways-to-create-the-error">Why are there so many ways to create the error?</a></h3>
<p>In short Rust has two classes to handle errors: a <strong>Result</strong> that allows for an error being returned if something fails and a <strong>Option</strong> which only allows None to be returned if something fails. Error handling is discussed in more detail in the <a href="80-ErrorHandling.html">Appendix</a>.</p>
<p>So if we re-compile this - will it work? If not just follow the compiler's help ;-)</p>
<h2 id="adding-a-test-for-read_table_with_names"><a class="header" href="#adding-a-test-for-read_table_with_names">Adding a Test for <code>read_table_with_names</code></a></h2>
<p><strong>Why Testing Matters</strong></p>
<p>Currently, our function compiles, but without a test, we cannot verify correctness. Unit testing ensures the function behaves as expected under various conditions.</p>
<h2 id="implementing-a-unit-test"><a class="header" href="#implementing-a-unit-test">Implementing a Unit Test</a></h2>
<p>Unit tests should be included at the end of the same file where the function is defined - there they can access private functions and variables of the class.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*; // Import everything from the parent module

    #[test]
    fn test_read_data() {
        match read_table_with_names("tests/data/Spellman_Yeast_Cell_Cycle.tsv", '\t') {
            Ok((rownames, data)) =&gt; {
                assert_eq!(data.len(), 256, "Expected 256 rows");
                assert_eq!(data[0].len(), 16, "Expected 16 columns");
                assert_eq!(rownames.len(), data.len(), "Row names should match row count");
            }
            Err(e) =&gt; {
                panic!("Could not read the TSV file: {e}");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<ul>
<li>Uses Rust's built-in testing framework (<code>#[test]</code> attribute).</li>
<li>Calls <code>read_table_with_names()</code> with a sample TSV file.</li>
<li>Asserts expected row and column counts, ensuring data integrity.</li>
<li>Panics with an error message if file reading fails.</li>
</ul>
<p>By adding this test, we verify that our function properly reads tabular data and correctly extracts row names and numeric values. I have a complete chapter on testing in Rust: @ref(testing).</p>
<p>For this to work we need to create the folder in our package and download <a href="https://github.com/shambam/R_programming_1/raw/refs/heads/main/Spellman_Yeast_Cell_Cycle.tsv">this file</a> there.</p>
<pre><code>mkdir -p tests/data
wget https://github.com/shambam/R_programming_1/raw/refs/heads/main/Spellman_Yeast_Cell_Cycle.tsv -O tests/data/Spellman_Yeast_Cell_Cycle.tsv
</code></pre>
<p>Now you can compile and test that the file is read correctly:</p>
<pre><code class="language-{bash}">cargo test -r
</code></pre>
<pre><code class="language-text">
running 1 test
test tests::test_read_data ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
test test_simulated_annealing ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


</code></pre>
<p>Cool! First class first class function and first test - and everything is working - or?</p>
<p>Lets also add a test for the new() function. This function should be accessible from outside and therefore we should create a new test file. Create the file <code>tests/test-SimulatedAnnealing.rs</code> and fill it with this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use simulated_annealing::SimulatedAnnealing; // load our library

#[test]
fn test_simulated_annealing() {
    let sa = SimulatedAnnealing::new( "tests/data/Spellman_Yeast_Cell_Cycle.tsv", 10, 200.0, '\t' );
    assert_eq!(sa.data.len(), 256, "we have 256 rows");
    assert_eq!(sa.data[0].len(), 16, "we have 16 cols");
}
<span class="boring">}</span></code></pre></pre>
<p>Test this again.</p>
<p>So all that is left is to implement the main simulated annealing algorithm!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="implement-the-simulated-annealing-algorithm"><a class="header" href="#implement-the-simulated-annealing-algorithm">Implement the Simulated Annealing Algorithm</a></h1>
<p>The idea behind this workshop is not to teach you how to implement the simulated annealing algorithm, but to show you how you can start to use Rust.
Therefore we will use Shamit's R implementation and convert that to Rust.</p>
<h2 id="scaling-of-the-data-or-why-scale01-in-r-is-fundamentally-flawed"><a class="header" href="#scaling-of-the-data-or-why-scale01-in-r-is-fundamentally-flawed">scaling of the data or "why <code>scale.01</code> in R is Fundamentally Flawed"</a></h2>
<h3 id="the-r-implementation"><a class="header" href="#the-r-implementation">The R Implementation</a></h3>
<p>The scale.01 function in R is defined as follows:</p>
<pre><code class="language-r">scale.01 &lt;- function(v){
  sc.01 &lt;- (v - min(v)) / (max(v) - min(v))
  sc.01
}
</code></pre>
<p>At first glance, this function seems to be a simple and effective way to scale a vector of numerical values between 0 and 1. And <strong>to state that clearly - it is perfectly valid R code</strong>. However, there are several fundamental issues with this implementation.</p>
<h3 id="the-problems-with-scale01"><a class="header" href="#the-problems-with-scale01">The Problems with scale.01</a></h3>
<ol>
<li>
<p><strong>Inefficiency:</strong> The function computes min(v) and max(v) twice. This is unnecessary and can significantly slow down performance when applied to large vectors.</p>
</li>
<li>
<p><strong>Vectorized but Inefficient in Apply Calls:</strong> The function is designed to be used in an apply() statement, which is idiomatic in R. However, repeatedly calling this function on subsets of data results in redundant computations.</p>
</li>
<li>
<p><strong>Mutation vs. Copying:</strong> In R, this function creates a new vector instead of modifying the existing one in place. This is inefficient for large datasets and contrasts with best practices in languages like Rust.</p>
</li>
</ol>
<h2 id="the-rust-approach"><a class="header" href="#the-rust-approach">The Rust Approach</a></h2>
<p>In Rust, the equivalent function would modify the existing data structure in place for efficiency. Here’s an example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scale_01(&amp;mut self) {
    for row in &amp;mut self.data {
        let mut min = f32::INFINITY;
        let mut range = f32::NEG_INFINITY;
        
        for &amp;value in row.iter() {
            min = min.min(value);
            range = range.max(value);
        }
        range -= min;
        for value in row.iter_mut() {
            *value = (*value - min) / range;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="why-the-rust-approach-is-better"><a class="header" href="#why-the-rust-approach-is-better">Why the Rust Approach is Better</a></h3>
<ol>
<li>
<p><strong>In-Place Modification:</strong> The Rust function modifies the existing data structure instead of creating unnecessary copies.</p>
</li>
<li>
<p><strong>Optimized Min/Max Computation:</strong> The min and max values are computed only once per row, avoiding redundant calculations.</p>
</li>
<li>
<p><strong>Memory Efficiency:</strong> By avoiding extra allocations, the Rust implementation is more memory-efficient, making it suitable for large datasets.</p>
</li>
<li>
<p><strong>Safety &amp; Performance:</strong> Rust enforces strict memory safety and avoids unintended data duplication, unlike R, where copies can be created implicitly.</p>
</li>
</ol>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<ul>
<li>R makes vectorized operations look simple but hides inefficiencies.</li>
<li>Rust requires explicit memory management but ensures better performance and correctness.</li>
</ul>
<h2 id="calculating-cluster-energy"><a class="header" href="#calculating-cluster-energy">Calculating Cluster Energy</a></h2>
<p>The R function <code>calc.Ek</code> calculates the energy of a specific cluster in a dataset. Here's the R code:</p>
<pre><code class="language-r">calc.Ek &lt;- function(m, clus, coi){
  clus.d &lt;- m[which(clus == coi), ]
  Ek &lt;- sum(dist(clus.d))
  Ek
}
</code></pre>
<h3 id="explanation-of-the-r-code"><a class="header" href="#explanation-of-the-r-code">Explanation of the R Code</a></h3>
<ol>
<li>
<p><strong>Selecting Rows for the Cluster</strong>:<br />
The first step in the R function is to create a new matrix, <code>clus.d</code>, that contains only the rows of the matrix <code>m</code> where the cluster label in the <code>clus</code> vector is equal to the cluster of interest <code>coi</code>. This is done using the <code>which()</code> function to find the indices of the rows that belong to the target cluster.</p>
</li>
<li>
<p><strong>Calculating the Energy</strong>:<br />
The function then calculates the energy (<code>Ek</code>) of the cluster by summing the pairwise Euclidean distances between all the rows in <code>clus.d</code>. The <code>dist()</code> function in R calculates the Euclidean distance between each pair of rows, and <code>sum()</code> is used to add these distances together.</p>
</li>
<li>
<p><strong>Output</strong>:<br />
The energy of the cluster (<code>Ek</code>) is returned as the result.</p>
</li>
</ol>
<h3 id="how-it-works-in-r"><a class="header" href="#how-it-works-in-r">How It Works in R</a></h3>
<ul>
<li>R makes use of high-level functions like <code>which()</code> and <code>dist()</code>, which simplify the implementation but may introduce some overhead due to the creation of intermediate data structures.</li>
</ul>
<h2 id="the-rust-implementation"><a class="header" href="#the-rust-implementation">The Rust Implementation</a></h2>
<p>The equivalent function in Rust is implemented with more explicit control over memory and data. Here's the Rust code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Function to compute the Euclidean distance between rows of data
fn euclidean_distance(&amp;self, i: usize, j: usize) -&gt; f32 {
    let v1 = &amp;self.data[i];
    let v2 = &amp;self.data[j];
    let mut sum: f32 = 0.0;
    for i in 0..v1.len() {
        sum += (v1[i] - v2[i]).powi(2);
    }
    sum.sqrt()
}

/// Calculates the cluster energy
fn calc_ek(&amp;self, clus: usize) -&gt; f32 {
    let ids = self.cluster_rows(clus);
    let mut sum = 0.0;
    for i in 0..ids.len() {
        for j in i+1..ids.len() {
            sum += self.euclidean_distance(ids[i], ids[j]);
        }
    }
    sum
}

/// Which rows are in cluster `clus`?
fn cluster_rows(&amp;self, clus: usize) -&gt; Vec&lt;usize&gt; {
    let mut ret = Vec::&lt;usize&gt;::with_capacity(self.clusters.len());
    for i in 0..self.clusters.len() {
        if self.clusters[i] == clus {
            ret.push(i);
        }
    }
    ret
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-of-the-rust-code"><a class="header" href="#explanation-of-the-rust-code">Explanation of the Rust Code</a></h3>
<ol>
<li>
<p><strong>Euclidean Distance Calculation</strong>:<br />
In Rust, the <code>euclidean_distance</code> function calculates the Euclidean distance between two rows. It takes the indices of the rows (<code>i</code> and <code>j</code>) and computes the sum of squared differences between corresponding elements in the rows. Finally, it returns the square root of the sum to get the distance.</p>
</li>
<li>
<p><strong>Cluster Energy Calculation</strong>:<br />
The <code>calc_ek</code> function calculates the energy of a cluster by:</p>
<ul>
<li>Finding the indices of the rows that belong to the specified cluster using the <code>cluster_rows</code> function.</li>
<li>For each pair of rows in the cluster, it computes the Euclidean distance and adds it to the total sum, which represents the cluster energy.</li>
</ul>
</li>
<li>
<p><strong>Cluster Rows</strong>:<br />
The <code>cluster_rows</code> function simply iterates over the <code>clusters</code> vector and collects the indices of the rows that belong to the specified cluster (<code>clus</code>). It returns a <code>Vec&lt;usize&gt;</code> containing these indices.</p>
</li>
</ol>
<h3 id="how-it-works-in-rust"><a class="header" href="#how-it-works-in-rust">How It Works in Rust</a></h3>
<ul>
<li>Rust gives you more control over memory and data access. The program works with mutable references and does not create intermediate data structures unless necessary.</li>
<li>The <code>cluster_rows</code> function is used to filter the rows based on the cluster, while the <code>euclidean_distance</code> function calculates the pairwise distance.</li>
</ul>
<p>That said, there are libraries that make Rust code look more like R, but I want to use as few libraries as possible here.</p>
<hr />
<h2 id="the-main-worker-function"><a class="header" href="#the-main-worker-function">The main worker function</a></h2>
<p>The R code provided implements the simulated annealing algorithm in the following steps:</p>
<ol>
<li><strong>Initial Cluster Assignment</strong>: A random assignment of K clusters to the rows of data is performed using <code>sample(1:K, nrow(data), replace = TRUE)</code>.</li>
<li><strong>Energy Calculation</strong>: The function <code>calc.Ek()</code> calculates the energy of the cluster (the sum of distances between elements within the cluster).</li>
<li><strong>Annealing Process</strong>: In each iteration, a row (data point) is randomly chosen and moved to a new cluster. The energy of the system is recalculated based on the new cluster assignment.</li>
<li><strong>Acceptance Criteria</strong>: If the new configuration has a lower energy, it is accepted. If the energy is higher, the new configuration is accepted based on a probabilistic criterion derived from the temperature (simulating the annealing process).</li>
<li><strong>Cooling</strong>: The temperature is updated in each iteration by multiplying it with a cooling factor.</li>
</ol>
<pre><code class="language-r">#This is the main algorithm that performs the annealing. It takes the data,how
#many K we are looking for, The number of iterations to perform, starting
#temperature and the cooling factor.

sa.ok &lt;- function(data,K,Iter,Temp,cool){

  clusters &lt;- sample(1:K,nrow(data),replace = T) #initialise random clusters
  
  #clusters.o &lt;- clusters
  
  Es.old &lt;- calc.E.all(data,clusters)
  #E.old &lt;- E.tot(Es.old)
 
  for(i in 1:Iter){   # start iterating 
    
    clusters.new &lt;- clusters #copy the clusters
    #Es.new &lt;- Es.old
    
    row.id &lt;- sample(1:nrow(data),1) #pick a gene at random
    
    from.c &lt;- clusters.new[row.id] # get the cluster it's moving from
    #to.c &lt;- sample((1:K)[!(1:K) %in% from.c],1)
    to.c &lt;- sample((1:K)[-from.c],1) # randomly choose a new cluster
    
    clusters.new[row.id] &lt;-  to.c # replace the old cluster with the new
    
    Es.new &lt;- Es.old #make a copy of the energies vector
    # calc the energies of the two changed clusters
    Es.new[from.c] &lt;- calc.Ek(data,clusters.new,from.c) 
    Es.new[to.c] &lt;- calc.Ek(data,clusters.new,to.c)
    
    E.new &lt;- E.tot(Es.new) # calculate the new average E
    E.old &lt;- E.tot(Es.old) # calculate the old average E
    
    if(E.new &lt; E.old){  # if new &lt; old accept the move copy the new clusters into the previous
      clusters &lt;-  clusters.new #copy the new clusters into the previous
      Es.old &lt;- Es.new # make Enew to Eold
    }else{
      
      if(calc.exp(E.new,E.old,Temp) &gt; runif(1)){ #evaluate the exprssion against the random number from runif(1)
        clusters &lt;- clusters.new #copy the new clusters into the previous
        Es.old &lt;- Es.new  # make Enew to Eold
      }
    }
    
    {cat("\r",E.old)} #print out the energy to the screen
    
    Temp &lt;- Temp*cool # cool the system
  }
  clusters # return the clusters
}
</code></pre>
<h3 id="rust-implementation"><a class="header" href="#rust-implementation">Rust Implementation</a></h3>
<p>The Rust version of the algorithm closely follows the same logic as the R implementation but is adapted for performance and memory safety in the Rust programming language:</p>
<ol>
<li><strong>Random Cluster Assignment</strong>: In Rust, clusters are assigned using <code>rand::random_range()</code> instead of the R <code>sample()</code> function.</li>
<li><strong>Energy Calculation</strong>: The energy calculation (<code>calc_ek()</code>) is similar to R’s <code>calc.Ek()</code>, but it uses a more efficient loop-based calculation of Euclidean distances.</li>
<li><strong>Annealing Process</strong>: The process for updating the cluster assignment and calculating energies is similar to the R version but is implemented with Rust’s ownership model and safety guarantees.</li>
<li><strong>Acceptance Criteria</strong>: The acceptance criterion is implemented with the same logic, but uses Rust’s <code>f32::exp()</code> to handle the energy calculations and probabilistic decision-making.</li>
<li><strong>Cooling</strong>: The temperature is updated similarly to R, using a multiplicative cooling factor.</li>
</ol>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn run( &amp;mut self, max_iter:usize, cool:f32 ) -&gt; usize {
    
      let mut it = 0;
      // calculate the inital energies - this will be modified later
      let mut old_energies= Vec::&lt;f32&gt;::with_capacity( self.k );
      for i in 0..self.k {
          old_energies.push( self.calc_ek( i ) );
      }
      
      let mut old_total: f32 = old_energies.iter().sum::&lt;f32&gt;() / self.k as f32;
      
      let mut rand = rand::rng();
      
      for _ in 0..max_iter{
          it += 1;
          // initate all varaibales
          let mut new_energies = old_energies.clone();
          let moving_row = rand.random_range(0..self.data.len());
          let move_from = self.clusters[moving_row];
          let mut move_to = rand.random_range(0..self.k);
          while move_from == move_to{
              move_to = rand.random_range(0..self.k);
          }
          // move the row from to
          self.clusters[moving_row] = move_to;
          // calculate the new energies
          new_energies[move_from] = self.calc_ek( move_from );
          new_energies[move_to] = self.calc_ek( move_to );
          
          let new_total:u32 = new_energies.iter().sum::&lt;f32&gt;() / self.k as f32;
          
          if new_total &lt; old_total || 
            (-((new_total - old_total) / self.temp)).exp() &gt; rand.random_range(0.0..1.0){
              // that is a good one - keep this
              old_energies[move_from] = new_energies[move_from];
              old_energies[move_to] = new_energies[move_to];
              old_total = new_total;
          }else {
              //this move was not good - drop it!
              self.clusters[moving_row] = move_from;
          }
          // cool the system
          self.temp *= cool;
      }
      it
    }
    
<span class="boring">}</span></code></pre></pre>
<p>There is not a lot of differences in the implementation - the rust code is even one line shorter than the R one.</p>
<h2 id="and-funtions-to-plot-and-write-the-data"><a class="header" href="#and-funtions-to-plot-and-write-the-data">And Funtions to Plot and Write the Data</a></h2>
<p>I assume that by now you understand what the write_clusters function is doing.</p>
<p>Plotting is a lot different from R; I have just obtained that function structure from ChatGPT and fixed some errors.
Just take it as is.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use plotters::prelude::*;
use std::error::Error;
use std::io::Write;

    pub fn write_clusters(&amp;self, ofile: &amp;str, sep: char) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        // Open the file in write mode
        let mut file = File::create(ofile)?;

        // Write the header (optional)
        writeln!(file, "Rowname{}Cluster", sep)?;

        // Iterate over the rownames and clusters, writing them to the file
        for (rowname, cluster) in self.rownames.iter().zip(self.clusters.iter()) {
            writeln!(file, "{}{}{}", rowname, sep, cluster+1)?;
        }

        Ok(())
    }
    
    pub fn plot(&amp;self, prefix:&amp;str )-&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let output_dir = Path::new(prefix).parent().unwrap_or_else(|| Path::new("."));
        std::fs::create_dir_all(output_dir)?;

        for cluster_id in 0..self.k {
            let filename = format!("{}_cluster_{}.png", prefix, cluster_id +1 );
            let root = BitMapBackend::new(&amp;filename, (800, 600)).into_drawing_area();
            root.fill(&amp;WHITE)?;

            let mut chart = ChartBuilder::on(&amp;root)
                .caption(format!("Cluster {}", cluster_id+1), ("sans-serif", 20))
                .margin(20)
                .x_label_area_size(40)
                .y_label_area_size(40)
                .build_cartesian_2d(0..self.data[0].len(), 0.0f32..1.0)?; // Adjust Y range if needed

            chart.configure_mesh().draw()?;

            // Collect all rows belonging to this cluster
            let cluster_data: Vec&lt;&amp;Vec&lt;f32&gt;&gt; = self.data.iter()
                .zip(&amp;self.clusters)
                .filter(|&amp;(_, &amp;c)| c == cluster_id)
                .map(|(row, _)| row)
                .collect();

            // Draw each row as a line plot
            for row in cluster_data {
                chart.draw_series(LineSeries::new(
                    row.iter().enumerate().map(|(x, &amp;y)| (x, y)),
                    &amp;BLUE,
                ))?;
            }

            root.present()?;
            println!("Saved: {}", filename);
        }

        Ok(())
    }

<span class="boring">}</span></code></pre></pre>
<p>The plot function needs one more library:</p>
<pre><code>cargo add plotters
</code></pre>
<p>If all has gone well we could improve on our tests!
Add a second test case into the lib.rs file:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[test]
    fn tes_scale01(){
        let mut obj = SimulatedAnnealing::new( "tests/data/Spellman_Yeast_Cell_Cycle.tsv", 8, 1000.0, '\t' );
        obj.scale_01();
        let exp5:Vec&lt;f32&gt; = vec![0.6989,0.0000,0.0968,0.3333,0.4301,1.0000,0.7419,0.7419,0.6022,0.7634,0.1720,0.4301,0.5161,0.7634,0.6989,0.6559];
        let exp7:Vec&lt;f32&gt; = vec![0.0803,0.0000,0.2867,0.5849,0.9679,1.0000,0.7775,0.7156,0.5505,0.5459,0.4518,0.6193,0.8440,0.8532,0.9335,0.7752];
        let mut dist: f32 = 0.0;
        for i in 0..exp5.len() {
            assert!(
                (obj.data[5][i] - exp5[i]).abs() &lt; 1e-4,
                "Mismatch in gene 5 at index {}: got {}, expected {}",
                i, obj.data[5][i], exp5[i]
            );
            assert!(
                (obj.data[7][i] - exp7[i]).abs() &lt; 1e-4,
                "Mismatch in gene 7 at index {}: got {}, expected {}",
                i, obj.data[7][i], exp7[i]
            );
            dist += (obj.data[7][i]-obj.data[5][i]).powi(2);
        }
        dist = dist.sqrt();
        obj.clusters[5] = 8;
        obj.clusters[7] = 8;
        obj.k =9;
        assert_eq!( obj.calc_ek(8), dist, "the distance in cluster 8 (genes 5 and 7)" );
    }
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-{bash eval=FALSE}">make test -r
</code></pre>
<pre><code class="language-text">
running 2 tests
test tests::tes_scale01 ... ok
test tests::test_read_data ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
test test_simulated_annealing ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


</code></pre>
<p>This looks good, just that we can not use this library as we have not implemented the executable :-D</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="rust-program-logioc-is-implemented-in-mainrs"><a class="header" href="#rust-program-logioc-is-implemented-in-mainrs">Rust Program Logioc is Implemented in "main.rs"</a></h1>
<p>If you compile the library as it is you will not be able to use it.
We need to implement the main.rs file that codes for the binary.</p>
<p>The R version of what we implement here is this:</p>
<pre><code class="language-r">
ycc &lt;- read.delim("../Spellman_Yeast_Cell_Cycle.tsv",row.names=1,header=T,sep="\t")
ycc &lt;- as.matrix(ycc)
ycc.01 &lt;- t(apply(ycc,1,scale.01))




system.time(proc.time(clus &lt;- sa.ok(ycc.01,10,25000,20,0.995)))

# plot the clusters using base R
par(mfrow=c(3,4))

for(i in 1:max(clus)){
  
  ycc.c &lt;- ycc.01[which(clus==i),]
  plot(ycc.c[1,],ty="l",ylim=range(ycc.c))
  apply(ycc.c,1,lines)
  
}
</code></pre>
<p>But as we implement this functionality as executable it would be better to not hardcode the options:</p>
<p>Command line options are normally parsed using the clap crate so we should add that to our project.
This time I want a specific version:</p>
<pre><code>cargo add clap@3.0.14 --features derive
</code></pre>
<p>We need to get the input table, the separating char for that table, the number of clusters to search for, the starting temperature, cool-down factor and max iterations to run through as well as the file we want to save the clusters to. In Rust you would do this like that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clap::Parser;

#[derive(Parser)]
#[clap(version = "1.0.0", author = "Stefan L. &lt;stefan.lang@med.lu.se&gt;")]
struct Opts {
    /// the input text table
    #[clap(short, long)]
    file: String,
    /// the column separator for the file
    #[clap(default_value= "\\t",short, long)]
    sep: String,
    /// the number of clusters
    #[clap(short, long)]
    clusters: usize,
    /// the starting temperature
    #[clap(default_value_t= 20.0,short, long)]
    temp: f32,
    /// the cooling factor
    #[clap(default_value_t= 0.9995,short, long)]
    cool: f32,
    ///max number of iterations
    #[clap(default_value_t= 1000*1000,short, long)]
    max_it: usize,
    /// the grouping outfile
    #[clap(short, long)]
    outfile: String,
}
<span class="boring">}</span></code></pre></pre>
<p>Here's a breakdown of what it's doing:</p>
<ol>
<li>
<p><strong>use clap::Parser;:</strong> This imports the necessary functionality from the clap crate, which is used for parsing command-line arguments.</p>
</li>
<li>
<p><strong>#[derive(Parser)]:</strong> This macro automatically implements the Parser trait for the Opts struct. This allows the struct to be used for argument parsing in the CLI.</p>
</li>
<li>
<p><strong>#[clap(version = "1.0.0", author = "Stefan L. <a href="mailto:stefan.lang@med.lu.se">stefan.lang@med.lu.se</a>")]:</strong> This defines metadata for the program such as its version and author, which will be shown when the user runs the command with a --version or --help flag.</p>
</li>
<li>
<p><strong>struct Opts { ... }:</strong> The Opts struct holds the various command-line arguments that the program will accept.
Each three lines corresponds to a command-line argument with hep srting, options and variable definition.</p>
</li>
</ol>
<p>The different clap options we are using here mean</p>
<ul>
<li><strong>short</strong> use the variable names first character for a short option like -f for file</li>
<li><strong>long</strong> use the variable name as long option line --file for file</li>
<li><strong>default_value</strong> the default String value if the user does not specify one</li>
<li><strong>default_value_t</strong> used for default values that are not a String</li>
</ul>
<p>The main function is quite simple — half of it is just calculating the time taken for the program to execute. Give it a try!</p>
<pre><pre class="playground"><code class="language-rust">use std::time::SystemTime;
// this is specific for my package which I have called simulated_annealing_new as I had an other version, too.
use simulated_annealing::SimulatedAnnealing;

fn main() {
    let now = SystemTime::now();
    
    let opts: Opts = Opts::parse();

    let mut sep = '\t';
    if &amp;opts.sep != "\\t"{
        //println!("I set sep to {}", opts.sep );
        sep = opts.sep.chars().next().unwrap(); 
    }

    let mut sim = SimulatedAnnealing::new( &amp;opts.file, opts.clusters, opts.temp, sep );
    sim.scale_01();    

    //println!("Initial state: {sim}");

    let iterations = sim.run( opts.max_it, opts.cool );

    let _= sim.plot( &amp;opts.outfile );

    //println!("Final state {sim} in {iterations} iterations");

    match sim.write_clusters( &amp;opts.outfile, sep ){
        Ok(_) =&gt; println!("Clusters written to {}", &amp;opts.outfile ),
        Err(e) =&gt; eprintln!("Failed to write the data to {}: {:?}", &amp;opts.outfile, e),
    }
    match now.elapsed() {
        Ok(elapsed) =&gt; {
            let hours = elapsed.as_secs() / 3600; // Calculate hours
            let minutes = (elapsed.as_secs() % 3600) / 60; // Calculate minutes
            let seconds = elapsed.as_secs() % 60; // Calculate remaining seconds
            let milliseconds = elapsed.subsec_millis(); // Milliseconds
            let microseconds = elapsed.subsec_micros(); // Microseconds (if needed)

            eprintln!(
                "finished in {} h {} min {} sec {} ms",
                hours, minutes, seconds, milliseconds
            );
        },
        Err(e) =&gt; {
            println!("Error: {e:?}");
        }
    }
}
</code></pre></pre>
<p>Now compile and test it:</p>
<pre><code class="language-{bash}">cargo test -r
</code></pre>
<pre><code class="language-text">
running 2 tests
test tests::tes_scale01 ... ok
test tests::test_read_data ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
test test_simulated_annealing ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


</code></pre>
<h2 id="we-have-an-executable"><a class="header" href="#we-have-an-executable">We have an Executable!!</a></h2>
<p>You now can run the executable target/release/simulated_annealing like that:</p>
<pre><code class="language-{bash}">target/release/simulated_annealing  -f tests/data/Spellman_Yeast_Cell_Cycle.tsv --clusters 8 --temp 20 --outfile /tmp/clusters.tsv --max-it 10000
</code></pre>
<pre><code class="language-text">
Saved: /tmp/clusters.tsv_cluster_1.png
Saved: /tmp/clusters.tsv_cluster_2.png
Saved: /tmp/clusters.tsv_cluster_3.png
Saved: /tmp/clusters.tsv_cluster_4.png
Saved: /tmp/clusters.tsv_cluster_5.png
Saved: /tmp/clusters.tsv_cluster_6.png
Saved: /tmp/clusters.tsv_cluster_7.png
Saved: /tmp/clusters.tsv_cluster_8.png
Saved: /tmp/clusters.tsv_cluster_9.png
Saved: /tmp/clusters.tsv_cluster_10.png
Clusters written to /tmp/clusters.tsv
finished in 0 h 0 min 0 sec 189 milli sec

</code></pre>
<h2 id="implement-a-print-for-our-class"><a class="header" href="#implement-a-print-for-our-class">Implement a 'print' for our Class</a></h2>
<p>The output from our simulation is missing key information — we want to display the system's energy before and after processing.</p>
<p>In an R S3 class, we would implement a custom print method like this:</p>
<pre><code class="language-r">print.simulatedAnnealing &lt;- function(x) {
  # Format and display info about x
}
</code></pre>
<p>This allows you to simply call <code>print(x)</code> and get a meaningful summary of the object.</p>
<p>Rust doesn't have classical inheritance like R's S3/S4 or R6 systems. Instead, Rust uses <strong>traits</strong>, which act like interfaces or capabilities. A type can implement a trait to gain specific behavior — similar to adding methods in R.</p>
<p>To define a custom print format in Rust, we implement the <code>Display</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for SimulatedAnnealing {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let mut sum = 0.0_f32;
        for i in 0..self.k {
            sum += self.calc_ek(i);
        }
        sum /= self.k as f32;
        write!(
            f,
            "SimulatedAnnealing (temperature: {:.2}, total energy: {:.2} for {} clusters)",
            self.temp, sum, self.k
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This gives the struct a user-friendly string representation, just like implementing <code>print()</code> for a class in R.</p>
<p>Afterwards we can change our main.rs and add the print statements:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let now = SystemTime::now();
    
    let opts: Opts = Opts::parse();

    let mut sep = '\t';
    if &amp;opts.sep != "\\t"{
        //println!("I set sep to {}", opts.sep );
        sep = opts.sep.chars().next().unwrap(); 
    }

    let mut sim = SimulatedAnnealing::new( &amp;opts.file, opts.clusters, opts.temp, sep );
    sim.scale_01();    

    println!("Initial state: {sim}");

    let iterations = sim.run( opts.max_it, opts.cool );

    let _= sim.plot( &amp;opts.outfile );

    println!("Final state after {iterations} iterations: {sim}");

    match sim.write_clusters( &amp;opts.outfile, sep ){
        Ok(_) =&gt; println!("Clusters written to {}", &amp;opts.outfile ),
        Err(e) =&gt; eprintln!("Failed to write the data to {}: {:?}", &amp;opts.outfile, e),
    }
    match now.elapsed() {
        Ok(elapsed) =&gt; {
            let hours = elapsed.as_secs() / 3600; // Calculate hours
            let minutes = (elapsed.as_secs() % 3600) / 60; // Calculate minutes
            let seconds = elapsed.as_secs() % 60; // Calculate remaining seconds
            let milliseconds = elapsed.subsec_millis(); // Milliseconds
            let microseconds = elapsed.subsec_micros(); // Microseconds (if needed)
    
            eprintln!(
                "finished in {} h {} min {} sec {} ms",
                hours, minutes, seconds, milliseconds
            );
        },
        Err(e) =&gt; {
            println!("Error: {e:?}");
        }
    }
}</code></pre></pre>
<p>I have not modified my examples here - so this is something you can do all for yourself.
If we have more time we could implement one more improvement to the library:</p>
<p>Add a store variable into the class and populate it with the row to row distances after you have scaled the data.
Then modify the calc_ek() function to use the values from the store and not calculate the distances every single time.
This modification will of cause be more beneficial if you run more iterations. If you calculate $1e+6$ iterations
you can get an additional 5x speed improvement by storing the euclidian distances as a Vec&lt;Vec<f32>&gt; again. If you use a single vector and an index function you could get an even better performance.</p>
<h2 id="take-home-message"><a class="header" href="#take-home-message">Take Home Message</a></h2>
<p>The implementation of the functions is significantly different from R or Python, but with the compiler and the AI assistance we can get at the moment it (2025), is doable. Coding in Rust takes time to get into, but the speed improvements can be worth it.</p>
<p>This example here does not really highlight the usability as the R code also finished in a reasonable amount of time, but if you have more complicated tasks - like processing BAM files or anything else that is (1) either easy to implement in a multiprocessor system or (2) needs to process binary data, it is worth to look into Rust. It is somewhat slower than C and C++ (up to 5 times?), but Rust is so much easier to program in if you come from R and Python - it is worth it.</p>
<p>By the way - I used a ArrayBase&lt;ndarray::OwnedRepr<f64>, Dim&lt;[usize; 2]&gt;&gt; for my store and gained another speed boost of factor 2. Given the fact that this takes either 60 or 30 milliseconds this is no big deal. For the sake of this tutorial I think a Vec&lt;Vec&lt;_&gt;&gt; is easier to work with. You can check out my other implementation <a href="https://github.com/stela2502/simulated_annealing">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="error-handling"><a class="header" href="#error-handling">Error Handling in Rust</a></h1>
<p>Rust provides a powerful error-handling system that helps ensure robustness and reliability. There are two main types of errors:</p>
<h2 id="1-unrecoverable-errors-panic"><a class="header" href="#1-unrecoverable-errors-panic">1. Unrecoverable Errors (<code>panic!</code>)</a></h2>
<p>Unrecoverable errors occur when the program reaches an unexpected state and must terminate immediately. Rust handles these with <code>panic!()</code>.</p>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("Something went wrong!");
}</code></pre></pre>
<h3 id="when-to-use-panic"><a class="header" href="#when-to-use-panic">When to Use <code>panic!()</code></a></h3>
<ul>
<li><strong>Critical failure</strong> where recovery is impossible.</li>
<li><strong>Development &amp; debugging</strong> to catch issues early.</li>
<li><strong>Assertions</strong> in tests using <code>assert!()</code> or <code>assert_eq!()</code>.</li>
</ul>
<h3 id="handling-panics-gracefully"><a class="header" href="#handling-panics-gracefully">Handling Panics Gracefully</a></h3>
<p>Instead of crashing the whole program, you can use <code>std::panic::catch_unwind()</code> to handle a panic in certain cases:</p>
<pre><pre class="playground"><code class="language-rust">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        panic!("This will be caught");
    });
    
    if result.is_err() {
        println!("A panic occurred, but the program is still running.");
    }
}</code></pre></pre>
<h2 id="2-recoverable-errors-resultt-e"><a class="header" href="#2-recoverable-errors-resultt-e">2. Recoverable Errors (<code>Result&lt;T, E&gt;</code>)</a></h2>
<p>Recoverable errors occur when an operation might fail but doesn't necessarily require termination. Rust uses the <code>Result&lt;T, E&gt;</code> type for these cases.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    let file = File::open("config.txt")?; // If error, return it
    Ok(())
}</code></pre></pre>
<h3 id="resultt-e-explanation"><a class="header" href="#resultt-e-explanation"><code>Result&lt;T, E&gt;</code> Explanation</a></h3>
<ul>
<li><code>Ok(T)</code>: The operation was successful and returns <code>T</code>.</li>
<li><code>Err(E)</code>: The operation failed and returns an error <code>E</code>.</li>
</ul>
<h3 id="common-ways-to-handle-resultt-e"><a class="header" href="#common-ways-to-handle-resultt-e">Common Ways to Handle <code>Result&lt;T, E&gt;</code></a></h3>
<h4 id="1-propagate-the-error--operator"><a class="header" href="#1-propagate-the-error--operator">1. <strong>Propagate the Error (<code>?</code> Operator)</strong></a></h4>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let content = std::fs::read_to_string("config.txt")?;
    Ok(content)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>?</code> operator <strong>short-circuits</strong> on <code>Err(E)</code>, returning it immediately.</li>
<li>Only works in functions that return <code>Result&lt;T, E&gt;</code>.</li>
</ul>
<h4 id="2-handle-the-error-manually"><a class="header" href="#2-handle-the-error-manually">2. <strong>Handle the Error Manually</strong></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let file = File::open("config.txt");
    match file {
        Ok(f) =&gt; println!("File opened successfully!"),
        Err(e) =&gt; println!("Failed to open file: {}", e),
    }
}</code></pre></pre>
<ul>
<li>The <code>match</code> statement allows custom error handling.</li>
</ul>
<h4 id="3-use-unwrap-or-expect-risky"><a class="header" href="#3-use-unwrap-or-expect-risky">3. <strong>Use <code>unwrap()</code> or <code>expect()</code></strong> <em>(Risky!)</em></a></h4>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let file = File::open("config.txt").unwrap(); // Panics if it fails
let file = File::open("config.txt").expect("Failed to open file"); // Custom panic message
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Use <strong>only if you are sure</strong> the operation will succeed.</li>
<li>Recommended for <strong>quick prototyping</strong> or <strong>tests</strong>.</li>
</ul>
<h4 id="4-using-unwrap_or-and-unwrap_or_else"><a class="header" href="#4-using-unwrap_or-and-unwrap_or_else">4. <strong>Using <code>unwrap_or()</code> and <code>unwrap_or_else()</code></strong></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let file = File::open("config.txt").unwrap_or_else(|_| {
        println!("File not found, creating a new one.");
        File::create("config.txt").expect("Failed to create file")
    });
}</code></pre></pre>
<ul>
<li><code>unwrap_or(default_value)</code> provides a fallback value.</li>
<li><code>unwrap_or_else(|err| handle_error(err))</code> allows custom error handling.</li>
</ul>
<hr />
<h2 id="3-custom-errors-with-thiserror-and-anyhow"><a class="header" href="#3-custom-errors-with-thiserror-and-anyhow">3. Custom Errors with <code>thiserror</code> and <code>anyhow</code></a></h2>
<p>For complex applications, defining custom error types is beneficial.</p>
<h3 id="using-thiserror-for-custom-errors"><a class="header" href="#using-thiserror-for-custom-errors">Using <code>thiserror</code> for Custom Errors</a></h3>
<pre><pre class="playground"><code class="language-rust  no_run">use std::fs::File;
use std::io::{self, Read};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MyError {
    #[error("File error: {0}")]
    FileError(std::io::Error),
    #[error("Invalid input: {0}")]
    InvalidInput(String),
}

fn read_file(file_name: &amp;str) -&gt; Result&lt;String, MyError&gt; {
    let mut file = File::open(file_name).map_err(MyError::FileError)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).map_err(MyError::FileError)?;
    Ok(contents)
}

fn main() {
    match read_file("example.txt") {
        Ok(contents) =&gt; println!("File content: {}", contents),
        Err(e) =&gt; println!("An error occurred: {}", e),
    }
}</code></pre></pre>
<ul>
<li>Use <code>#[error("message")]</code> to format error messages.</li>
<li>Allows structured error handling.</li>
</ul>
<h3 id="using-anyhow-for-simpler-error-handling"><a class="header" href="#using-anyhow-for-simpler-error-handling">Using <code>anyhow</code> for Simpler Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::{Context, Result};
use std::fs::File;

fn open_file() -&gt; Result&lt;File&gt; {
    let file = File::open("config.txt").context("Could not open config file")?;
    Ok(file)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>anyhow::Result&lt;T&gt;</code> allows returning <strong>multiple error types</strong> easily.</li>
<li><code>.context()</code> provides <strong>custom error messages</strong>.</li>
</ul>
<hr />
<h2 id="summary-of-rust-error-handling-techniques"><a class="header" href="#summary-of-rust-error-handling-techniques">Summary of Rust Error Handling Techniques</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Technique</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>panic!()</code></td><td>Unrecoverable errors that should crash the program.</td></tr>
<tr><td><code>Result&lt;T, E&gt;</code></td><td>Recoverable errors where failure is an expected possibility.</td></tr>
<tr><td><code>?</code> operator</td><td>Propagating errors in functions returning <code>Result&lt;T, E&gt;</code>.</td></tr>
<tr><td><code>match</code></td><td>Custom error handling logic.</td></tr>
<tr><td><code>unwrap()</code> / <code>expect()</code></td><td>Quick debugging, <strong>but avoid in production</strong>.</td></tr>
<tr><td><code>unwrap_or()</code> / <code>unwrap_or_else()</code></td><td>Provide default values or custom error handling.</td></tr>
<tr><td><code>thiserror</code></td><td>Custom structured error types.</td></tr>
<tr><td><code>anyhow</code></td><td>Simple error handling with better error messages.</td></tr>
</tbody></table>
</div>
<p>By following these practices, you can write <strong>safe, reliable, and robust Rust applications</strong>! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="testing"><a class="header" href="#testing">Testing in Rust</a></h1>
<p>Rust has a built-in testing framework that enables developers to write and run tests efficiently. Tests help ensure code correctness, prevent regressions, and improve maintainability.</p>
<h2 id="1-writing-basic-unit-tests"><a class="header" href="#1-writing-basic-unit-tests">1. Writing Basic Unit Tests</a></h2>
<p>Rust tests are written inside a module annotated with <code>#[cfg(test)]</code> and individual tests use <code>#[test]</code>.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_addition() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>#[cfg(test)]</code> ensures the module is only compiled when running tests.</li>
<li><code>#[test]</code> marks a function as a test.</li>
<li><code>assert_eq!(a, b)</code> checks if <code>a == b</code>, failing the test otherwise.</li>
</ul>
<h3 id="common-assertions"><a class="header" href="#common-assertions">Common Assertions:</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assert!(condition)</code></td><td>Fails if condition is false.</td></tr>
<tr><td><code>assert_eq!(a, b)</code></td><td>Fails if <code>a != b</code>, shows values.</td></tr>
<tr><td><code>assert_ne!(a, b)</code></td><td>Fails if <code>a == b</code>, shows values.</td></tr>
</tbody></table>
</div>
<h2 id="2-running-tests"><a class="header" href="#2-running-tests">2. Running Tests</a></h2>
<p>To execute all tests, run:</p>
<pre><code class="language-sh">cargo test
</code></pre>
<ul>
<li>Runs all test functions inside <code>#[cfg(test)]</code> modules.</li>
<li>Captures standard output unless <code>--nocapture</code> is used:
<pre><code class="language-sh">cargo test -- --nocapture
</code></pre>
</li>
<li>Runs specific tests using:
<pre><code class="language-sh">cargo test test_addition
</code></pre>
</li>
</ul>
<h2 id="3-testing-for-panics"><a class="header" href="#3-testing-for-panics">3. Testing for Panics</a></h2>
<p>Use <code>#[should_panic]</code> to test for expected panics.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = "divide by zero")]
fn test_divide_by_zero() {
    let _ = 1 / 0;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The test passes if it panics with the expected message.</li>
</ul>
<h2 id="4-using-resultt-e-in-tests"><a class="header" href="#4-using-resultt-e-in-tests">4. Using <code>Result&lt;T, E&gt;</code> in Tests</a></h2>
<p>Instead of panicking, tests can return <code>Result&lt;(), E&gt;</code> for better error handling.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_file_reading() -&gt; Result&lt;(), std::io::Error&gt; {
    let content = std::fs::read_to_string("test_file.txt")?;
    assert!(content.contains("Hello"));
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Recommended for tests involving I/O or other fallible operations.</li>
</ul>
<h2 id="5-ignoring-tests"><a class="header" href="#5-ignoring-tests">5. Ignoring Tests</a></h2>
<p>Some tests may take a long time. Use <code>#[ignore]</code> to exclude them from default runs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]
fn long_running_test() {
    std::thread::sleep(std::time::Duration::from_secs(10));
}
<span class="boring">}</span></code></pre></pre>
<p>Run ignored tests with:</p>
<pre><code class="language-sh">cargo test -- --ignored
</code></pre>
<h2 id="6-benchmarking-with-bench"><a class="header" href="#6-benchmarking-with-bench">6. Benchmarking with <code>#[bench]</code></a></h2>
<p>Rust provides benchmarking via the <code>test</code> crate (nightly only):</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span>#![feature(test)]
<span class="boring">fn main() {
</span>extern crate test;
use test::Bencher;

#[bench]
fn bench_addition(b: &amp;mut Bencher) {
    b.iter(|| 2 + 2);
}
<span class="boring">}</span></code></pre></pre>
<p>Run benchmarks with:</p>
<pre><code class="language-sh">cargo bench
</code></pre>
<h2 id="7-integration-tests"><a class="header" href="#7-integration-tests">7. Integration Tests</a></h2>
<p>Integration tests are placed in the <code>tests/</code> directory and test the external interface of the library.</p>
<h3 id="example-testsintegration_testrs"><a class="header" href="#example-testsintegration_testrs">Example <code>tests/integration_test.rs</code>:</a></h3>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use my_crate::add;

#[test]
fn test_add() {
    assert_eq!(add(2, 3), 5);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Uses <code>use my_crate::*;</code> to import public API functions.</li>
<li>Each file in <code>tests/</code> is compiled separately.</li>
</ul>
<h2 id="8-testing-the-executable"><a class="header" href="#8-testing-the-executable">8. Testing the Executable</a></h2>
<p>For projects that generate a binary, you can test the executable by running it as a subprocess and checking its output.</p>
<h3 id="example-teststest_binaryrs"><a class="header" href="#example-teststest_binaryrs">Example <code>tests/test_binary.rs</code>:</a></h3>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::process::Command;

#[test]
fn test_executable_output() {
    let output = Command::new("target/debug/my_binary")
        .arg("--version")
        .output()
        .expect("Failed to execute binary");
    
    let stdout = String::from_utf8_lossy(&amp;output.stdout);
    assert!(stdout.contains("my_binary 1.0.0"));
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Uses <code>std::process::Command</code> to execute the compiled binary.</li>
<li>Checks if the output matches the expected version string.</li>
</ul>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>#[test]</code></td><td>Defines a unit test.</td></tr>
<tr><td><code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code></td><td>Assertion macros.</td></tr>
<tr><td><code>cargo test</code></td><td>Runs all tests.</td></tr>
<tr><td><code>#[should_panic]</code></td><td>Tests expected panics.</td></tr>
<tr><td><code>Result&lt;(), E&gt;</code></td><td>Allows fallible tests.</td></tr>
<tr><td><code>#[ignore]</code></td><td>Skips tests unless explicitly run.</td></tr>
<tr><td><code>cargo bench</code></td><td>Runs performance benchmarks (nightly only).</td></tr>
<tr><td>Integration Tests</td><td>Stored in <code>tests/</code>, test public APIs.</td></tr>
<tr><td>Executable Testing</td><td>Uses <code>std::process::Command</code> to verify binary output.</td></tr>
</tbody></table>
</div>
<p>By following these testing best practices, you can ensure your Rust code is robust, maintainable, and reliable! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="-intro-to-traits-in-rust-for-bioinformaticians"><a class="header" href="#-intro-to-traits-in-rust-for-bioinformaticians">🧬 Intro to Traits in Rust (For Bioinformaticians)</a></h1>
<p>In Rust, traits are like interfaces in other languages — they define a shared set of behavior that different types can implement.</p>
<p>Think of traits like protocols that say:</p>
<pre><code>*“If you implement this trait, you must define how these functions behave.”*
</code></pre>
<p>This is especially powerful in bioinformatics where you may want to define a common interface for different types of genomic data, file formats, or processing strategies.</p>
<p>For example, you might have different structs for processing a GTF or a BED file — but if they both implement a FeatureMatcher trait, you can treat them the same in generic code.</p>
<h2 id="-trait-example"><a class="header" href="#-trait-example">🧪 Trait Example</a></h2>
<p>Let's say we want to define a trait for something that can match a read to a gene feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait FeatureMatcher { 

/// prepare the class for ordered process_feature calls
fn init_search(&amp;self, chr: &amp;str, start: usize, iterator: &amp;mut ExonIterator) -&gt; Result&lt;(), QueryErrors&gt;; 

/// implements a Class specific way to postprocess multiplets
fn extract_gene_ids(&amp;self, read_result: &amp;Option&lt;Vec&lt;ReadResult&gt;&gt;, data: &amp;ReadData, mapping_info: &amp;mut MappingInfo) -&gt; Vec&lt;String&gt;; 

/// the main function processing one (paired) BAM entry
fn process_feature( &amp;self, data: &amp;(ReadData, Option&lt;ReadData&gt;), mutations: &amp;Option&lt;MutationProcessor&gt;, iterator: &amp;mut ExonIterator, exp_gex: &amp;mut SingleCellData, exp_idx: &amp;mut IndexedGenes, mut_gex: &amp;mut SingleCellData, mut_idx: &amp;mut IndexedGenes, mapping_info: &amp;mut MappingInfo, match_type: &amp;MatchType, ); 

} 
<span class="boring">}</span></code></pre></pre>
<p>Now, any struct (like GTF or BedData) that implements FeatureMatcher can be used generically:</p>
<pre><code> fn process_chunk&lt;T: FeatureMatcher + Sync + Send&gt;(...) { ... } 
</code></pre>
<p>This is powerful for writing reusable code — especially for large-scale pipelines, format conversions, or multimodal analysis tools.</p>
<h3 id="-what-are-send-and-sync--and-why-do-we-need-them"><a class="header" href="#-what-are-send-and-sync--and-why-do-we-need-them">🧵 What Are <code>Send</code> and <code>Sync</code> — and Why Do We Need Them?</a></h3>
<p>When writing parallel code in Rust — which is common in bioinformatics for speeding up large data analyses — the compiler needs to <strong>guarantee thread safety</strong>.</p>
<p>Rust uses two special "auto traits" to track this:</p>
<h4 id="-send"><a class="header" href="#-send">✅ <code>Send</code></a></h4>
<p>A type is <code>Send</code> if it’s safe to <strong>move</strong> it to another thread.</p>
<p>Think: <em>"Can I pass this thing into a thread and not worry about it blowing up?"</em></p>
<h4 id="-sync"><a class="header" href="#-sync">✅ <code>Sync</code></a></h4>
<p>A type is <code>Sync</code> if it’s safe to <strong>share a reference</strong> (<code>&amp;T</code>) between threads.</p>
<p>Think: <em>"Can multiple threads safely read this at the same time?"</em></p>
<hr />
<h3 id="-why-it-matters-for-traits"><a class="header" href="#-why-it-matters-for-traits">🧪 Why It Matters for Traits</a></h3>
<p>When we define a trait like <code>FeatureMatcher</code>, and we want to use it in multithreaded code (e.g., via <code>Arc&lt;dyn FeatureMatcher&gt;</code>), Rust needs to know:</p>
<blockquote>
<p>“Is this trait object safe to move or share between threads?”</p>
</blockquote>
<p>To answer that, we add these trait bounds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FeatureMatcher: Send + Sync {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>This ensures that any struct implementing <code>FeatureMatcher</code> is guaranteed to be thread-safe — making your code safer, faster, and more parallel-friendly by default.</p>
<h2 id="-why-traits-matter-in-bioinformatics"><a class="header" href="#-why-traits-matter-in-bioinformatics">💡 Why Traits Matter in Bioinformatics</a></h2>
<p><strong>Traits let you:</strong></p>
<ul>
<li>Design modular code where the implementation details are abstracted away</li>
<li>Work with different formats using a unified API</li>
<li>Enable parallelization safely with Sync + Send</li>
<li>Write testable and flexible pipelines</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
